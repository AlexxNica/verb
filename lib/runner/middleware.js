'use strict';

var middleware = require('./middleware/');
var utils = require('../utils');
var falsey = require('falsey');
var diff = require('base-diff');

module.exports = function(app, base, env) {
  // `view` plugin that add a `isType` method to views
  app.use(function fn(view) {
    if (!view.isView) return fn;

    view.define('isType', function(type) {
      return this.options.viewType.indexOf(type) !== -1;
    });
  });

  /**
   * Readme dest path
   */

  app.onLoad(/\.verb\.md/, function(view, next) {
    view.path = view.dest = 'readme.md';
    next();
  });


  app.onLoad(/\.md/, middleware.examples(app));

  app.onLoad(/\.md/, function(view, next) {
    if (hasToc(view)) {
      // don't render or insert a TOC
      view.options.toc = view.options.toc || {};
      view.options.toc.render = true;
      view.options.toc.insert = true;
      verb.data.toc = '';
    }
    next();
  });

  /**
   * Table of contents > adds `file.data.toc` property
   */

  var append = '\n\n_(TOC generated by [verb](https://github.com/verbose/verb) using [markdown-toc](https://github.com/jonschlinkert/markdown-toc))_';
  app.preRender(/\.md/, renderToc(app, 'preRender', append));


  app.preRender(/./, function(view, next) {
    view.data.options = view.options;
    next();
  });

  /**
   * Diff files (currently just testing readme)
   */

  app.preRender(/./, diff.view('diffLines'));
  app.postRender(/./, function(view, next) {
    var diff = app.option('diff');
    if (diff && diff === true || diff === view.stem) {
      view.diff();
    }
    next();
  });

  /**
   * Determine layout
   */

  app.preLayout(/\.md/, function(view, next) {
    if (view.isType('partial')) {
      next();
      return;
    }

    var layout = app.pkg.get('verb.layout')
    if (utils.isObject(layout)) {
      var opts = layout;
      layout = layout.name;
    }

    if (typeof layout !== 'undefined') {
      view.layout = layout;
      next();
      return;
    }
    next();
  });

  app.postLayout(/./, renderToc(app, 'postLayout', append));

  app.preWrite(/package\.json$/, function(view, next) {
    view.dest = 'package.json';
    next();
  });

  app.preWrite(/\.md$/, function(view, next) {
    if (!view.actions.has('toc') && view.data.toc) {
      view.content = insertToc(view.content, view.data.toc);
      view.actions.set('toc');
    }
    next();
  });
};

function renderToc(app, stage, append) {
  return function(view, next) {
    var opts = utils.merge({append: append, toc: {}}, app.options);
    if (view.isType('partial') || isDisabled(opts, view, 'toc')) {
      view.content = stripToc(view.content);
      next();
      return;
    }

    var toc = utils.toc(app, opts);

    // ensure the TOC isn't injected until after formatting
    view.options.toc = { insert: false };
    toc(view, next);
  };
}

function hasToc(view) {
  if (view.get('options.toc.inserted') === true) {
    return true;
  }
  if (view.content.indexOf('<!-- toc -->') !== -1) {
    return true;
  }
}

function tocInjected(view) {
  if (view.get('options.toc.inserted') === true) {
    return true;
  }
  if (view.content.indexOf('<!-- rendered_toc -->') !== -1) {
    return true;
  }
}

function stripToc(str) {
  str = str.split('<!-- rendered_toc -->').join('');
  str = str.split('<!-- toc -->').join('');
  return str;
}

function insertToc(str, toc) {
  if (!toc) return;
  str = str.split('<!-- rendered_toc -->').join(toc);
  str = str.split('<!-- toc -->').join(toc);
  return str;
}

function isDisabled(opts, view, prop) {
  return isFalsey(utils.get(opts, prop))
      || isFalsey(utils.get(view.options, prop))
      || isFalsey(utils.get(view.data, prop))
}

function isFalsey(val) {
  if (typeof val === 'undefined') {
    return false;
  }
  if (!utils.isObject(val)) {
    return falsey(val);
  }
}
