'use strict';

var utils = require('../utils');
var falsey = require('falsey');
var diff = require('base-diff');

module.exports = function(app, base, env) {
  app.use(function fn(view) {
    if (!view.isView) return fn;

    view.define('isType', function(type) {
      return this.options.viewType.indexOf(type) !== -1;
    });
  });

  /**
   * Readme dest path
   */

  app.onLoad(/\.verb\.md/, function(view, next) {
    view.path = view.dest = 'readme.md';
    next();
  });

  /**
   * Table of contents > adds `file.data.toc` property
   */

  var append = '\n\n_(TOC generated by [verb](https://github.com/verbose/verb))_';
  app.preRender(/\.md/, renderToc(app, 'preRender', append));

  /**
   * Diff files (currently just testing readme)
   */

  app.preRender(/./, diff.view('diffLines'));
  app.postRender(/./, function(view, next) {
    var diff = app.option('diff');
    if (diff && diff === true || diff === view.stem) {
      view.diff();
    }
    next();
  });

  app.preLayout(/\.md/, function(view, next) {
    if (view.isType('partial')) return next();

    // working on a better method for this!
    var layout = app.get('env.user.pkg.verb.layout');
    if (typeof layout !== 'undefined') {
      view.layout = layout;
      return next();
    }

    if (typeof view.layout === 'string' || isFalsey(view)) {
      return next();
    }

    if (needsLayout(view.content)) {
      view.layout = 'default';
    }
    next();
  });

  app.postLayout(/./, renderToc(app, 'postLayout', append));

  app.preWrite(/package\.json$/, function(view, next) {
    view.dest = 'package.json';
    next();
  });
};

// TODO: implement better check
function needsLayout(str) {
  if (!/^# /.test(str)) {
    return true;
  }
  return false;
}

function isFalsey(view) {
  if (typeof view.layout === 'undefined' && falsey(view.layout)) {
    return true;
  }
  return false;
}

function renderToc(app, stage, append) {
  return function(view, next) {
    if (view.isType('partial') || isDisabled(app, view, 'toc')) {
      view.content = stripToc(view.content);
      next();
      return;
    }

    var opts = utils.merge({append: append, toc: {}}, app.options);
    if (typeof opts.toc.insert === 'undefined') {
      opts.toc.insert = false;
    }
    var toc = utils.toc(app, opts);
    toc(view, next);
  };
}

function stripToc(str) {
  return str.split('<!-- toc -->').join('');
}

function isDisabled(app, view, prop) {
  return isFalsey(app.option(prop))
      || isFalsey(view.options[prop])
      || isFalsey(view.data[prop]);
}

function isFalsey(val) {
  if (typeof val === 'undefined') {
    return false;
  }
  if (val && !isPrimitive(val)) {
    return false;
  }
  return falsey(val);
}
