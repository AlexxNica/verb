'use strict';

var diff = require('base-diff');
var middleware = require('./middleware/');
var utils = require('../utils');

module.exports = function(app, base, env) {

  /**
   * Readme dest path
   */

  app.onLoad(/\.verb\.md/, function(view, next) {
    view.path = view.dest = 'readme.md';
    next();
  });

  /**
   * Table of contents > adds `file.data.toc` property
   */

  var append = '_(TOC generated by [verb](https://github.com/verbose/verb) using [markdown-toc](https://github.com/jonschlinkert/markdown-toc))_';

  app.postLayout(/\.md/, middleware.toc.create(app, append));
  app.preWrite(/\.md/, middleware.toc.inject(app, append));

  app.onLoad(/\.md/, middleware.reflinks(app));
  app.onLoad(/\.md/, middleware.examples(app));

  // /**
  //  * Merge options onto `view.data`
  //  */

  app.preRender(/./, function(view, next) {
    view.data.options = utils.merge({}, view.data.options, view.options);
    next();
  });

  /**
   * Diff files (currently just testing readme)
   */

  app.preRender(/./, diff.view('diffLines'));
  app.postRender(/./, function(view, next) {
    var diff = app.option('diff');
    if (diff && diff === true || diff === view.stem) {
      view.diff();
    }
    next();
  });

  /**
   * Determine layout
   */

  app.preLayout(/\.md/, function(view, next) {
    if (view.isType('partial')) {
      next();
      return;
    }
    var layout = app.pkg.get('verb.layout');
    if (utils.isObject(layout)) {
      var opts = layout;
      layout = layout.name;
    }
    if (typeof layout !== 'undefined') {
      view.layout = layout;
    }
    next();
  });

  app.preWrite(/package\.json$/, function(view, next) {
    view.dest = 'package.json';
    next();
  });
};
